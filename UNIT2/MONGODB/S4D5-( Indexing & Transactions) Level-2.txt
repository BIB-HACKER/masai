2. Create an index based on the name of the students given on the Level-1 assignment
=> db.students.createIndex({"name":1})

3. Retrieve the top 5 best-selling products based on the total quantity sold
=> db.orders.aggregate([{$group:{_id:"$products.product_id",total:{$sum:"$products.quantity_ordered"}}},{$sort:{total:-1}},{$limit:5}])

4. Create an aggregation query to list all products a specific customer has purchased.
=> db.orders.aggregate([{$match:{"customer_id":customer_id}},{$lookup:{from:"products",localField:"product_id",foreignField:"_id",as:"product"}},
   {$project:{_id:0,product:"$product.name",quantity:"$quantity_ordered"}}])

5. Find the most popular product category based on the total number of products sold in the last month
=> db.orders.aggregate([{$match:{order_date:{$gte:"2023-10-01",$lt:"2023-11-01"}}},{$lookup:{from:"products",localField:"products.product_id",foreignField:"_id",as:"product"}},{$unwind:"$product"},
  {$group:{_id:"$product.category",totalSold:{$sum:"$quantity_ordered"}}},{$sort:{totalSold:-1}},{$limit:1}])

6. Calculate the average order value for each month over the past year.
=> db.e-commerce_orders.aggregate([{$group:{_id:{$month:"$order_date"},averageOrderValue:{$avg:{$sum:{$multiply:["$quantity_ordered","$unit_price"]}}}}}])

7. Write an aggregation query to identify products that are running low in stock (e.g., less than 10 units in stock).
=> db.products.aggregate([{$match:{"quantity_in_stock":{$lt:10}}}])

8. Determine the top 10 customers with the highest total purchase value over their lifetime
=> db.orders.aggregate([{$group:{_id:"$customer_id",totalPurchase:{$sum:{$multiply:["$quantity_ordered","$unit_price"]}}}},{$sort:{ totalPurchase:-1}},{$limit:10}])

9. Calculate the average time between orders for each customer
=> db.orders.aggregate([{$sort:{customer_id:1,order_date:1}},{$group:{_id:"$customer_id",avgOrders:{$avg:{$subtract:["$order_date",{$lag:"$order_date"}]}}}}])

10. Use $lookup to associate each product with its supplier information, and then find the supplier with the highest total revenue
=> db.orders.aggregate([{$lookup:{from:"products",localField:"products.product_id",foreignField:"_id",as:"product"}},{$unwind:"$product"},{$group:{_id:"$product.supplier",
   totalRevenue:{$sum:{$multiply:["$product.quantity_ordered","$product.unit_price"]}}}},{$sort:{totalRevenue:-1}},{$limit:1}])

11. Identify customers who have not made a purchase in the last three months and determine their count
=> db.orders.aggregate([{$group:{_id:"$customer_id",lastOrderDate:{$max:"$order_date"}}},{$match:{lastOrderDate:{$lt:"2023-09-08"}}},{$group:{_id:null,count:{$sum:1}}}])

12. Find products that are often purchased together with a specific product, and recommend them as cross-sell items
=> db.orders.aggregate([{$match:{"products.product_id":specificProductId}},{$unwind:"$products"},{$match:{"products.product_id":{$ne:specificProductId}}},
   {$group:{_id:"$products.product_id",count:{$sum:1}}},{$lookup:{from:"products",localField:"_id",foreignField:"_id",as:"product"}},
   {$project:{product_id:"$_id",count:1,product_name:{$arrayElemAt:["$product.name",0]},product_price:{$arrayElemAt:["$product.price",0]}}},{$sort:{count:-1}}])

13. Use aggregations to segment customers into three categories: high-value, medium-value, and low-value, based on their total purchase history
=> db.orders.aggregate([{$match:{"product_id":productId}},{$group:{_id:"$_id",otherProducts:{$push:"$product_id"}}},{$unwind:"$otherProducts"},{$group:{_id:"$otherProducts",count:{$sum:1}}},
   {$sort:{count:-1}},{$limit:5}])


14. Calculate the return rate for each product category, considering the ratio of returned products to total products sold in the last quarter
=> 

15. Calculate the inventory turnover rate for each product category, indicating how quickly products are sold and replaced in stock.
=>